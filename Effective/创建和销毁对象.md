# 创建和销毁对象 #
## 考虑用静态工厂方法代替构造器 ##
### 优点 ###
1. **它们有名称**
如果构造器参数本身没有确切地描述被返回的独享,那么具有适当名称的静态工厂会更容易使用.

1. **不必每次创建新对象**
可以使用预先构建好的实例,或者将构建好的实例对象缓存起来,进行重复利用.

1. **可以返回任何类型的子类对象**
这种灵活性的应用可以根据API返回对象,同时又不会使对象的类便成功哟,以这种方式隐藏实现类会使API变得非常简洁.适用于基于接口的框架.

这种实现方式在进行版本替换的时候,可以从容的选择不同的实现方式,而不会造成什么不良影响.

### 缺点 ###
1. **类如果不含共有的或受保护的构造器,就不能被子类化**
即子类无法被创建,只能创建父类,但是也同样因为如此因祸得福,因为它鼓励使用复合(接口 ),而不是继承.

1. **它们与其他的静态方法实际上没有区别.**
在API文档中,它们没有像构造器那样在API文档中明确表示出来.因此要查明如何实例化一个类是非常困难的.

## 遇到多个构造参数时要考虑用构建起 ##
静态工厂和构造器有个共同的局限性,它们都不能很好地扩展到大量可选参数,考虑用一个类表示很多参数时,有些属性必须的,有些属性非必须,

**重叠构造器模式**
提供不同参数长度的构造器,但是这样在参数变多的时候,构造器的编写将变得异常麻烦.切难以阅读.

**JavaBeans**
通过无参构造器来创建对象,通过set方法来设置必要参数,以及相关可选参数.这样创建实例很容易,并且可读性也很不错.但是因为构造过程被分到几个调用中,在构造过程中javaBeans可能处于不一致的状态,类无法仅仅通过校验构造器参数的有效性来保证一致性.通知阻止了把类做成不可变的模式.这就需要额外的努力来保证它的线程安全

**builder**
不直接生成想要的对象,而是利用所有必要的参数调用构造器,得到一个builder对象,然后在builder对象上调用类似于set方法,来设置每个相关的可选参数.最后客户端调用无参的build方法来生成不可变对象

与构造器相比,builder的微弱优势在于,builder可以由多个可变(vararge)参数,构造器就像方法一样,只能有一个可变参数.

**总结**
如果类的构造器或者静态工厂中具有多个参数,设计这种累时,builder模式就是中不错的选择,特别是大多数参数都是可选的时候,与传统重叠构造器模式相比,builder模式将更容易阅读和编写,构建起也比JavaBeans更安全

## 用私有构造器或者枚举类型强化Singleton属性 ##
Singleton指仅仅被实例化一次的类,Singleton通常被用来代表那些本质上唯一的系统组件.
使用工厂进行Singleton时优势在于它提供了灵活性,在不改变其API前提下,我们可以该是该类是否为Singleton的想法,或为每个线程返回一个唯一的Singleton等.

## 通过私有构造器强化不可实例化的能力 ##
有时候需要编写一些只包含静态方法,和静态域的工具类,这样的工具类不希望被实例化,实例化对它没有任何意义,然而在缺少显示构造器的情况下,编译器会自动构建一个共有,无参的缺省构造器.
此时将显示构造器声明为私有,并且抛出异常就断绝了被实例化的可能.

## 避免创建不必要的对象 ##
能重用的对象最好重用而不是在每次需要的时候在创建一个相同功能的新对象.
怼图同时提供静态工厂方法和构造器的不可变类,通常使用工厂方法而不是构造器,避免创建不必要的对象.构造器在每次被调用的时候都会创建一个新的对象,而静态工厂方法从来不要求这么做,实际上也不会这么做.

不要错误的认为`创建对象的代价非常昂贵,我们应该尽可能避免创建对象`,相反,由于小对象的构造器只做很少量的显式工作,所以小对象创建和回收动作是非常廉价的,特别是在现代的JVM实现上更是如此.通过创建附加的对象,提升程序的清晰性,简洁性和功能性,这通常是件好事.

反制,通过维护自己的对象池,来避免创建对象并不是一种好的做法,除非池中的对象是非常重量级的.
但是一般而言,维护自己的对象池必定会把代码弄得很乱,同时增加内存占用,并且还会损害性能,现代的JVM实现具有高度优化的垃圾回收期,其性能很容易就超过轻量级的对象池的性能.

## 消除过期的对象引用 ##
在Java这种具有垃圾回收功能的语言的时候,内存泄漏也将变得更加隐蔽.
如下
```
public class Stack {
    private Object[] eleents;
    private int size = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 16;

    public Stack() {
    }

    public void push(Object e) {
        ensureCapacity();
        eleents[size++] = e;
    }

    public Object pop() {
        if (size == 0) {
            throw new EmptyStackException();
        }
        return eleents[--size];
    }

    private void ensureCapacity() {
        if (eleents.length == size) {
            eleents = Arrays.copyOf(eleents, 2 * size + 1);
        }
    }
}
```
这段程序中并没有什么明显的错误,并且无论怎么测试也可以正常通过测试,但是存在着隐藏的内存泄漏问题.
如果一个栈显示增长,然后在收缩,那么栈中弹出来的对象呢将不会被当做垃圾回收,即使使用栈的程序已经不在引用这些对象,它们也不会被回收,因为栈内部维护着对这些对象的`过期引用`.
所谓的过期引用指的是用会不会被解除的引用,在本例中,凡是在element数组的"活动部分"只玩的任何引用都是过期的.活动部分指的是element中下表小于size的元素.
在支持垃圾回收的语言中,内存泄漏是很隐蔽的(称这类内存泄漏为"无意识的对象保持").
如果一个对象引用被无意识的的保留起来了,那么垃圾回收机制不仅不会处理这个对象,而且也不会处理被这个对象所引用的其他对象.

一般而言,`只要类是自己管理内存,程序员就应该警惕内存泄漏问题`,一旦元素被释放掉,则该元素中包含的任何对象应用都因该被清空.

## 避免使用终结方法 ##
终结方法`finalizer`通常是不可预测的,也是很危险的,一般情况下是不必要的.使用终结方法会导致行为不稳定,降低性能,以及可移植性问题,当然终结方法也有其可用之处,
Java语言规范不仅不保证终结方法会被及时执行,而且根本就不保证它们会被执行,当一个程序终止的时候,某些已经无法访问的对象上的终结方法缺根本没有被执行.这完全是有可能的,结论是:`不应该依赖终结方法来更新重要的持久状态.`