# 对象导论 #
我们之所以将自然界分解,组织成各种概念,并按其含义分类,主要是因为我们是整个口语交流社会共同遵守的协定的参与者,这个协定以语言的形式固定下来....除非赞成这个协定中规定的有关语言信息和组织和分类,否则我们根本无法交谈.

计算机革命起源于机器,编程语言的产生也始于对机器的模仿.

## 抽象过程 ##
所有编程语言都提供抽象机智,人们所能解决的问题的复杂性直接取决于**抽象的类型和质量**.
- 类型
	- **所抽象的是什么?**,汇编语言是对底层机器的轻微抽象.接着出现的许多所谓**命令式**语言都是对汇编语言的抽象.
	- 这些语言在汇编语言基础上有了大幅的改进,但是他们所做的**主要抽象**仍要求在解决问题时要**基于计算机的解构**,而不是基于**所解决的问题的解构来考虑**.
	
- **面向对象**
	- 通过向程序员提供表示问题空间中的元素的工具而更进了一步.使得程序员不受限于任何特定类型的问题,将这种问题空间中的元素及其在解空间中的表示称为**对象**.
	- 程序可以通过添加新类型的对象使自身适用于某个特定问题.
	- 允许根据问题来描述问题,而不是根据运行解决方案的计算机来描述问题.
	
1. 万物皆为对象 
	- 将对象视为奇特的变量,他可以储存数据,除此之外还可以要求它在自身上执行操作.
1. 程序是对象的集合,它们通过发送消息来告知彼此所要做的.
	- 要想请求一个对象,就必须对该对象发送一条消息.
1. 每个对象都有自己的由其他对象所构成的储存
	- 可以通过创建包含现有对象的包的方式来创建新的类型对象.
1. 每个对象都拥有其类型
	- 每个对象都是某个类的**实例**.
1. 某一特定类型的所有对象都可以接受同样的消息.
	- 例如**圆形**类型的对象同时也是**几何形**类型对象.所以一个**圆形**对象必定能接受发送给**几何形**对象的消息.

## 每个对象都有一个接口 ##
创建抽象数据类型是面向对象程序设计的基本概念之一.

类描述了具有相同特性和行为的对象集合,实际上就是一个数据类型.

面向对象方法并不是仅局限于构建仿真程序,即任何程序都是你所设计的系统的一种仿真,面向对象技术的应用确实可以将大量的问题很容易讲解为一个简单的解决方案.

每个对象都只能满足某些请求,这些请求由对象的**接口**所定义.接口确定了对某一特定对象所能发出的请求.

## 每个对象都提供服务 ##
当正在试图开发或理解一个程序设计时,最好的方法之一就是讲对象相像为**服务提供者**.程序本身将向用户提供服务,它将通过调用其他对象提供的服务来实现这一目的.

将对象看做是服务提供者还有一个附带的好处:它有助于提高对象的内聚性,**高内聚**是软件设计的基本质量要求之一.
- 高内聚
	- 这意味着一个软件架构(例如一个的对象,也可能是指一个方法或一个对象库)的各方面**组合**得很好.每个对象都可以很好的完成一项任务,但是它并不试图做更多的事.

## 被隐藏的具体实现 ##
只想使用者暴露必须的部分,而隐藏其他部分,这意味着可以任意修改被隐藏的部分,而不用担心对其他任何人造成影响.
如果没有任何访问控制,所有东西都将赤裸裸地暴露在世人面前.

## 复用具体实现 ##
最简单地复用某各类的方法就是直接使用该类的一个对象,此外也可以将那个类的一个对象置于某个新的类中.我们称其为**创建一个成员对象**.新的类可以由任意数量,任意类型的其他对象以任意可以实现新的类中想要的功能的方式组成.这种概念称为**组合**,如何组合是动态发生的,那么它通常称为**聚合**,组合经常被视为**has-a**关系.

## 继承 ##
两个类型可以有相同的特性和行为,但是其中一个的类型可能比另一个含有更多特性,并且可以处理更多的消息(或以不同的方式来处理消息).

## **是一个**与**像是一个**关系 ##
继承只覆盖基类的方法,并不添加在基类中没有的新方法,在某种意义上,这是一种处理继承的理想方式.称为**is-a**关系.
在继承类中添加了新的接口元素,这样也扩展了接口,这个新的类型荏苒可以替代基类,但是这种替代并不完美,因为基类无法访问新添加的方法,这种情况我们描述为**is-like-a**关系

## 伴随多态的可互换对象 ##
在处理类型的层级结构时,经常想把一个对象不当做它所属的特定类型来对待.而是将其作为基类对象来对待.这使得人们可以编写出不依赖于特限定类型的代码.

## 单继承结构 ##
在OOP中,自C++面世以来就已变得非常瞩目的一个问题就是,是佛所有的类最终都继承自单一的基类.

在单根继承结构中所有的对象都具有一个共有接口,所以他们归根到底都是相同的基本类型.