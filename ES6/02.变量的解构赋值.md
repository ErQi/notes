## 数组的解构赋值 ##
ES6允许按照一定模式,从数组和对象中提取之,对变量进程赋值.

### 基本用法 ###
ES6允许按照一定模式,从数组和对象中提取只,对变量进行复制,这被称为结构(Destructuring)
以前为变量赋值,只能直接指定值.
```
let a = 1;
let b = 2;
let c = 3;
```
ES6允许写成下面这样.
```
let [a, b, c] = [1, 2, 3];
```
上面代码表示,可以从数组中提取值,按照对应位置,对变量赋值.

本质上,这种写法输入模式匹配.只要等号两边的模式相同,左边的变量就会被赋予对应的值,下面是常见例子
```
let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3

let [ , , third] = ["foo", "bar", "baz"];
third // "baz"

let [x, , y] = [1, 2, 3];
x // 1
y // 3

let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

let [x, y, ...z] = ['a'];
x // "a"
y // undefined
z // []
```
如果解构不成功,变量的值等于undefined.
```
let [foo] = [];
let [bar, foo] = [1];
```
以上两种情况都属于解构不成功,foo的值都会等于undefined.

另一种情况是不完全结构,即等号左边的模式,职匹配一部分的等号右边的数组,这种情况下,结构依然可以成功.
```
let [x, y] = [1, 2, 3];
x // 1
y // 2

let [a, [b], d] = [1, [2, 3], 4];
a // 1
b // 2
d // 4
```
如上,都属于不完全结构,但是都可以成功.

入股等号右边不是数组(或者严格地说,不是可遍历的结构)那么将会报错.
```
// 报错
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};
```
上面语句全部报错,因为等号右边的值,要么转为对象以后不具备Iterator接口,要么本身就不具备Iterator接口.

对于Set结构,也可以使用数组的解构赋值.
```
let [x, y, z] = new Set(['a', 'b', 'c']);
x // "a"
```

### 默认值 ###
解构赋值允许制定默认值
```
let [foo = true] = [];
foo // true

let [x, y = 'b'] = ['a']; // x='a', y='b'
let [x, y = 'b'] = ['a', undefined]; // x='a', y='b'
```
注意ES6内部使用严格相等运算符(===)判断一个位置是否有值,所以如果一个数组成员不严格等于undefined,默认值不会生效.
```
let [x = 1] = [undefined];
x // 1

let [y = 1] = [null];
x // null
```
上面代码中,第二行y的默认值就未生效,给定的值非undefined,然后就会被给定的值取代默认值.

如果默认值是一个表达式,那么这个表达式是惰性求值,只有在用到的时候才会求值.
```
function f() {
  console.log('aaa');
}

let [x = f()] = [1];
```
如上代码,因为有赋值1,所以函数f根本未执行.

默认值可以引用解构赋值的其他变量,但该变量必须已经声明
```
let [x = 1, y = x] = [];     // x=1; y=1
let [x = 1, y = x] = [2];    // x=2; y=2
let [x = 1, y = x] = [1, 2]; // x=1; y=2
let [x = y, y = 1] = [];     // ReferenceError
```


### 对象的解构赋值 ###
解构不仅可以用于数组,还可以用于对象.
```
let { foo, bar } = { foo: "aaa", bar: "bbb" };
foo // "aaa"
bar // "bbb"
```
对象的解构与数组有一个重要的不同,数组的元素是按次序排列的,变量的取值由它的位置决定,而对象的属性没有次序,变量必须与属性同名,才能正确取值.

//TODO 对象的扩展需了解.