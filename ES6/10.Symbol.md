# Symbol #

## 概述 ##
ES5的独享属性名都是字符串,容易造成属性名冲突,ES6引入Symbol就是为了解决这个问题,它能保证每个属性的名字都是独一无二的.

Symbol是ES6的一种新的原始数据类型,表示第一无二的值,它是JavaScript语言的第七种数据类型.

Symbol值通过**Symbol**函数生成,也就代表属性名可以有两种类型,一种是原来的字符串,另一种就是新增的Symbol类型.
凡是属性名属于Symbol类型就都是独一无二,可以保证不会与其他属性名冲突.
```
let s = Symbol();

typeof s
// "symbol"
```
上面代码中,变量s就是第一无二的值,typeof运算符的结果,表示数据类型是Symbol数据类型.

注意,Symbol函数前不能使用new命令,负责会报错,因为生成的Symbol是一个原始类型的值,不是对象.

Symbol函数可以接受一个字符串作为参数,表示对Symbol实例的描述,主要是为了在控制台显示,或转化为字符串时容易区分.
```
let s1 = Symbol('foo');
let s2 = Symbol('bar');

s1 // Symbol(foo)
s2 // Symbol(bar)

s1.toString() // "Symbol(foo)"
s2.toString() // "Symbol(bar)"
```
如果Symbol的参数是一个对象,就会调用该对象的toString方法,将其转化为字符串,然后才生成一个Symbol值.
```
const obj = {
  toString() {
    return 'abc';
  }
};
const sym = Symbol(obj);
sym // Symbol(abc)
```
Symbol函数的参数表示对当前的Symbol值的描述,因此相同参数的Symbol函数的返回值是不相等的.
```
// 没有参数的情况
let s1 = Symbol();
let s2 = Symbol();

s1 === s2 // false

// 有参数的情况
let s1 = Symbol('foo');
let s2 = Symbol('foo');

s1 === s2 // false
```
Symbol值不能与其他类型的值进行运算,会报错.
```
let sym = Symbol('My symbol');

"your symbol is " + sym
// TypeError: can't convert symbol to string
`your symbol is ${sym}`
// TypeError: can't convert symbol to string
```
但是Symbol值可以显式转为字符串.
```
let sym = Symbol('My symbol');

String(sym) // 'Symbol(My symbol)'
sym.toString() // 'Symbol(My symbol)'
```
另外Symbol值也可以转为布尔值,但是不能转为数值.
```
let sym = Symbol();
Boolean(sym) // true
!sym  // false

if (sym) {
  // ...
}

Number(sym) // TypeError
sym + 2 // TypeError
```

## 作为属性名的Symbol ##
由于每一个Symbol值都是不相等的,这意味着Symbol的值可以作为标识符,用于对象的属性名,就能保证不会出现同名问题,这对于一个对象由多个模块 构成的情况非常有用,能防止某一个键不小心改写或覆盖.
```
let mySymbol = Symbol();

// 第一种写法
let a = {};
a[mySymbol] = 'Hello!';

// 第二种写法
let a = {
  [mySymbol]: 'Hello!'
};

// 第三种写法
let a = {};
Object.defineProperty(a, mySymbol, { value: 'Hello!' });

// 以上写法都得到同样结果
a[mySymbol] // "Hello!"
```

注意,Symbol值作为对象属性名时,不能用点运算符.
```
const mySymbol = Symbol();
const a = {};

a.mySymbol = 'Hello!';
a[mySymbol] // undefined
a['mySymbol'] // "Hello!"
```
上面代码中,因为点运算符后面总是字符串,所以不会读取.

同理在对象内部,使用Symbol值定义属性时,Symbol值必须放在方括号中.
```
let s = Symbol();

let obj = {
  [s]: function (arg) { ... }
};

obj[s](123);
```
上面代码中,如果s不放在方括号中,该属性的键名就是字符串s,而不是s所代表的Symbol值.

采用增强对象写法,上面代码的obj对象可以写的更简洁一些.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   
```
let obj = {
  [s](arg) { ... }
};
```
Symbol类型害了一用于定义一组常量,保证这组常量的值都是不相等的. 
```
log.levels = {
  DEBUG: Symbol('debug'),
  INFO: Symbol('info'),
  WARN: Symbol('warn')
};
log(log.levels.DEBUG, 'debug message');
log(log.levels.INFO, 'info message');
```
下面是另一个例子
```
const COLOR_RED    = Symbol();
const COLOR_GREEN  = Symbol();

function getComplement(color) {
  switch (color) {
    case COLOR_RED:
      return COLOR_GREEN;
    case COLOR_GREEN:
      return COLOR_RED;
    default:
      throw new Error('Undefined color');
    }
}
```
常量使用Symbol的好处在于其他任何值都不可能会出现相同的情况,可以保证switch语句会按设计方式工作.

需要注意,Symbol值作为属性名时,该属性还是公开属性,不是私有属性.

## 实例:消除魔术字符串 ##
魔术字符串指的是,在代码中多次出现,与代码形成强耦合的某一个具体的字符串或者数值,风格良好的代码,应该尽量消除魔术字符串,改由含义清晰的变量代替.
```
function getArea(shape, options) {
  let area = 0;

  switch (shape) {
    case 'Triangle': // 魔术字符串
      area = .5 * options.width * options.height;
      break;
    /* ... more code ... */
  }

  return area;
}

getArea('Triangle', { width: 100, height: 100 }); // 魔术字符串
```
上面代码中,字符串Triangle就是一个魔术字符串,它多次出现,与代码形成强耦合,不利于将来的修改和维护

常用的消除魔术字符串的方法就是把它写成一个变量.
```
const shapeType = {
  triangle: 'Triangle'
};

function getArea(shape, options) {
  let area = 0;
  switch (shape) {
    case shapeType.triangle:
      area = .5 * options.width * options.height;
      break;
  }
  return area;
}

getArea(shapeType.triangle, { width: 100, height: 100 });
```
把Triangle写成shapeType对象的triangle属性，这样就消除了强耦合。

其实shapeType.triangle等于那个值并不重要,只要确保不会跟其他shapeType属性的值冲突即可,因此这里就很适合改用Symbol值.
```
const shapeType = {
  triangle: Symbol()
};
```

## 属性名的遍历 ##
Symbol作为属性名,该属性不会出现在`for...in`,`for...of`循环中,也不会被`Object.keys()`,`Object.getOwnPropertyNames()`,`JSON.stringify()`返回,但是它也不是私有属性,有一个`Object.getOwnPropertySymbols`方法可以获取制定对象的所有Symbol属性名.

`Object.getOwnPropertySymbols`方法返回一个数组,成员是当前对象的所有用作属性名的Symbol值.
```
const obj = {};
let a = Symbol('a');
let b = Symbol('b');

obj[a] = 'Hello';
obj[b] = 'World';

const objectSymbols = Object.getOwnPropertySymbols(obj);

objectSymbols
// [Symbol(a), Symbol(b)]
```
下面的另一个例子`Object.getOwnPropertySymbols`方法与`for...in`循环,`Object.getOwnPropertyNames`方法进行对比的例子.
```
const obj = {};

let foo = Symbol("foo");

Object.defineProperty(obj, foo, {
  value: "foobar",
});

for (let i in obj) {
  console.log(i); // 无输出
}

Object.getOwnPropertyNames(obj)
// []

Object.getOwnPropertySymbols(obj)
// [Symbol(foo)]
```
上面代码中使用`Object.getOwnPropertyNames(obj)`方法得不到`Symbol`属性名,需要使用`Object.getOwnPropertySymbols(obj)`方法

另一个新的API,`Reflect.ownKeys`方法可以返回所有类型的键名,包括常规键名和Symbol键名
```
let obj = {
  [Symbol('my_key')]: 1,
  enum: 2,
  nonEnum: 3
};

Reflect.ownKeys(obj)
//  ["enum", "nonEnum", Symbol(my_key)]
```
由于Symbol值作为名称的属性,不会被常规方法遍历得到,我们可以利用这个特性,为对象定义一些费私有,但又希望只用于内部的方法.
```
let size = Symbol('size');

class Collection {
  constructor() {
    this[size] = 0;
  }

  add(item) {
    this[this[size]] = item;
    this[size]++;
  }

  static sizeOf(instance) {
    return instance[size];
  }
}

let x = new Collection();
Collection.sizeOf(x) // 0

x.add('foo');
Collection.sizeOf(x) // 1

Object.keys(x) // ['0']
Object.getOwnPropertyNames(x) // ['0']
Object.getOwnPropertySymbols(x) // [Symbol(size)]
```
上面代码中,对象x的size属性是一个Symbol值,所以`Object.keys(x)`,`Object.getOwnPropertyNames(x)`都无法获取它,这就造成了一种非私有的内部方法的效果.

## Symbol.for(),Symbol.keyFor() ##
又是否我们希望重复使用一个Symbol值,Symbol.for方法就可以做到这一点,它接受一个字符串作为参数,然后搜索有没有以该参数作为名称的Symbol值,如果有就返回这个Symbol值.否则就新建一个以该字符串为名称的Symbol值并返回.
```
let s1 = Symbol.for('foo');
let s2 = Symbol.for('foo');

s1 === s2 // true
```
Symbol.keyFor方法返回一个已经被Symbol.for记录过的Symbol类型值的key,如下.
```
let s1 = Symbol.for("foo");
Symbol.keyFor(s1) // "foo"

let s2 = Symbol("foo");
Symbol.keyFor(s2) // undefined
```
上面代码中s2变量没有被Symbol.for记录过,于是就返回了undefined.

需要注意,Symbol.for记录的Symbol对象是全局环境的,可以再不同iframe或者service worker中取到同一个值.
```
iframe = document.createElement('iframe');
iframe.src = String(window.location);
document.body.appendChild(iframe);

iframe.contentWindow.Symbol.for('foo') === Symbol.for('foo')
```
上面代码中，iframe 窗口生成的 Symbol 值，可以在主页面得到.

## 实例:模块的Singleton模式 ##
既然上面可以作为唯一属性,那么在需要单例对象的时候自然也不是问题.
